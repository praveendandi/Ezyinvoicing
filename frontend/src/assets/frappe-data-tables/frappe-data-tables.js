var DataTable = function (t, e) { "use strict"; function n(t, e) { return "string" == typeof t ? (e || document).querySelector(t) : t || null } function i(t) { var e = typeof t; return null != t && ("object" == e || "function" == e) } function o(t) { var e = T.call(t, L), n = t[L]; try { t[L] = void 0; var i = !0 } catch (t) { } var o = H.call(t); return i && (e ? t[L] = n : delete t[L]), o } function s(t) { return W.call(t) } function r(t) { return null == t ? void 0 === t ? z : O : A && A in Object(t) ? _(t) : j(t) } function a(t) { return null != t && "object" == typeof t } function l(t) { return "symbol" == typeof t || F(t) && B(t) == D } function c(t) { if ("number" == typeof t) return t; if (N(t)) return V; if (I(t)) { var e = "function" == typeof t.valueOf ? t.valueOf() : t; t = I(e) ? e + "" : e } if ("string" != typeof t) return 0 === t ? t : +t; t = t.replace(q, ""); var n = P.test(t); return n || X.test(t) ? U(t.slice(2), n ? 2 : 8) : K.test(t) ? V : +t } function h(t, e, n) { function i(e) { var n = d, i = f; return d = f = void 0, b = e, g = t.apply(i, n) } function o(t) { return b = t, p = setTimeout(a, e), C ? i(t) : g } function s(t) { var n = t - b, i = e - (t - w); return y ? Q(i, m - n) : i } function r(t) { var n = t - w, i = t - b; return void 0 === w || n >= e || n < 0 || y && i >= m } function a() { var t = E(); if (r(t)) return l(t); p = setTimeout(a, s(t)) } function l(t) { return p = void 0, x && d ? i(t) : (d = f = void 0, g) } function c() { void 0 !== p && clearTimeout(p), b = 0, d = w = f = p = void 0 } function h() { return void 0 === p ? g : l(E()) } function u() { var t = E(), n = r(t); if (d = arguments, f = this, w = t, n) { if (void 0 === p) return o(w); if (y) return p = setTimeout(a, e), i(w) } return void 0 === p && (p = setTimeout(a, e)), g } var d, f, m, g, p, w, b = 0, C = !1, y = !1, x = !0; if ("function" != typeof t) throw new TypeError(G); return e = Z(e) || 0, I(n) && (C = !!n.leading, m = (y = "maxWait" in n) ? J(Z(n.maxWait) || 0, e) : m, x = "trailing" in n ? !!n.trailing : x), u.cancel = c, u.flush = h, u } function u(t, e, n) { var i = !0, o = !0; if ("function" != typeof t) throw new TypeError(tt); return I(n) && (i = "leading" in n ? !!n.leading : i, o = "trailing" in n ? !!n.trailing : o), Y(t, e, { leading: i, maxWait: e, trailing: o }) } function d(t) { return t.replace(/([A-Z])/g, t => `-${t[0].toLowerCase()}`) } function f(t) { return Object.keys(t).map(e => { const n = d(e); const i = t[e]; if (void 0 === i) return ""; return `data-${n}="${i}" ` }).join("").trim() } function m(t) { var e = document.createElement("textarea"); e.style.position = "fixed", e.style.top = 0, e.style.left = 0, e.style.width = "2em", e.style.height = "2em", e.style.padding = 0, e.style.border = "none", e.style.outline = "none", e.style.boxShadow = "none", e.style.background = "transparent", e.value = t, document.body.appendChild(e), e.select(); try { document.execCommand("copy") } catch (t) { console.log("Oops, unable to copy") } document.body.removeChild(e) } function g(t) { return !isNaN(t) } function p(t, e = null) { return (...n) => new Promise(i => { const o = () => { const o = t.apply(e, n); i(o) }; window.setImmediate ? setImmediate(o) : window.requestAnimationFrame ? requestAnimationFrame(o) : setTimeout(o) }) } function w(t, e, n) { const i = n.reduce((t, n) => { t[n] = { get() { return e[n] } }; return t }, {}); Object.defineProperties(t, i) } function b(t) { return void 0 !== t || null !== t } function C(t) { return !b(t) } function y(t) { return !isNaN(t) } function x(t) { return Array.isArray(t) ? t : [t] } t = t && t.hasOwnProperty("default") ? t.default : t, e = e && e.hasOwnProperty("default") ? e.default : e, n.each = ((t, e) => "string" == typeof t ? Array.from((e || document).querySelectorAll(t)) : t || null), n.create = ((t, e) => { let i = document.createElement(t); for (let t in e) { let o = e[t]; if ("inside" === t) n(o).appendChild(i); else if ("around" === t) { let t = n(o); t.parentNode.insertBefore(i, t), i.appendChild(t) } else "styles" === t ? "object" == typeof o && Object.keys(o).map(t => { i.style[t] = o[t] }) : t in i ? i[t] = o : i.setAttribute(t, o) } return i }), n.on = ((t, e, i, o) => { o ? n.delegate(t, e, i, o) : (o = i, n.bind(t, e, o)) }), n.off = ((t, e, n) => { t.removeEventListener(e, n) }), n.bind = ((t, e, n) => { e.split(/\s+/).forEach(function (e) { t.addEventListener(e, n) }) }), n.delegate = ((t, e, n, i) => { t.addEventListener(e, function (t) { const e = t.target.closest(n); e && (t.delegatedTarget = e, i.call(this, t, e)) }) }), n.unbind = ((t, e) => { if (t) for (let n in e) { let i = e[n]; n.split(/\s+/).forEach(function (e) { t.removeEventListener(e, i) }) } }), n.fire = ((t, e, n) => { let i = document.createEvent("HTMLEvents"); i.initEvent(e, !0, !0); for (let t in n) i[t] = n[t]; return t.dispatchEvent(i) }), n.data = ((t, e) => { if (!e) return t.dataset; for (const n in e) t.dataset[n] = e[n] }), n.style = ((t, e) => { if ("string" == typeof e) return n.getStyle(t, e); Array.isArray(t) || (t = [t]); t.map(t => { for (const n in e) t.style[n] = e[n] }) }), n.removeStyle = ((t, e) => { Array.isArray(t) || (t = [t]); Array.isArray(e) || (e = [e]); t.map(t => { for (const n of e) t.style[n] = "" }) }), n.getStyle = ((t, e) => { let n = getComputedStyle(t)[e];["width", "height"].includes(e) && (n = parseFloat(n)); return n }), n.closest = ((t, e) => { if (!e) return null; if (e.matches(t)) return e; return n.closest(t, e.parentNode) }), n.inViewport = ((t, e) => { const { top: top, left: left, bottom: bottom, right: right } = t.getBoundingClientRect(); const { top: pTop, left: pLeft, bottom: pBottom, right: pRight } = e.getBoundingClientRect(); return top >= pTop && left >= pLeft && bottom <= pBottom && right <= pRight }), n.scrollTop = function (t, e) { requestAnimationFrame(() => { t.scrollTop = e }) }, n.scrollbarWidth = function () { const t = document.createElement("div"); n.style(t, { width: "100px", height: "100px", overflow: "scroll", position: "absolute", top: "-9999px" }), document.body.appendChild(t); const e = t.offsetWidth - t.clientWidth; return document.body.removeChild(t), e }; var I = i, v = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, R = "object" == typeof v && v && v.Object === Object && v, S = "object" == typeof self && self && self.Object === Object && self, $ = R || S || Function("return this")(), E = function () { return $.Date.now() }, k = $.Symbol, M = Object.prototype, T = M.hasOwnProperty, H = M.toString, L = k ? k.toStringTag : void 0, _ = o, W = Object.prototype.toString, j = s, O = "[object Null]", z = "[object Undefined]", A = k ? k.toStringTag : void 0, B = r, F = a, D = "[object Symbol]", N = l, V = NaN, q = /^\s+|\s+$/g, K = /^[-+]0x[0-9a-f]+$/i, P = /^0b[01]+$/i, X = /^0o[0-7]+$/i, U = parseInt, Z = c, G = "Expected a function", J = Math.max, Q = Math.min, Y = h, tt = "Expected a function"; let et = u, nt = Y; class it { constructor(t) { this.options = t, this.sortRows = p(this.sortRows, this), this.switchColumn = p(this.switchColumn, this), this.removeColumn = p(this.removeColumn, this), this.filterRows = p(this.filterRows, this) } init(t, e) { t || (t = this.options.data), e && (this.options.columns = e), this.data = t, this.rowCount = 0, this.columns = [], this.rows = [], this.prepareColumns(), this.prepareRows(), this.prepareTreeRows(), this.prepareRowView(), this.prepareNumericColumns() } get currentSort() { return this.columns.find(t => "none" !== t.sortOrder) || { colIndex: -1, sortOrder: "none" } } prepareColumns() { this.columns = [], this.validateColumns(), this.prepareDefaultColumns(), this.prepareHeader() } prepareDefaultColumns() { if (this.options.checkboxColumn && !this.hasColumnById("_checkbox")) { const t = { id: "_checkbox", content: this.getCheckboxHTML(), editable: !1, resizable: !1, sortable: !1, focusable: !1, dropdown: !1, width: 32 }; this.columns.push(t) } if (this.options.serialNoColumn && !this.hasColumnById("_rowIndex")) { let t = { id: "_rowIndex", content: "", align: "center", editable: !1, resizable: !1, focusable: !1, dropdown: !1 }; this.columns.push(t) } } prepareHeader() { let t = this.columns.concat(this.options.columns); const e = { isHeader: 1, editable: !0, sortable: !0, resizable: !0, focusable: !0, dropdown: !0, width: null, format: t => { if (null === t || void 0 === t) return ""; return t + "" } }; this.columns = t.map((t, e) => this.prepareCell(t, e)).map(t => Object.assign({}, e, t)).map(t => { t.content = t.content || t.name || ""; t.id = t.id || t.content; return t }) } prepareCell(t, e) { const n = { content: "", sortOrder: "none", colIndex: e, column: this.columns[e] }; return null !== t && "object" == typeof t ? Object.assign(n, t) : n.content = t, n } prepareNumericColumns() { const t = this.getRow(0); t && (this.columns = this.columns.map((e, n) => { const i = t[n].content; !e.align && i && g(i) && (e.align = "right"); return e })) } prepareRows() { this.validateData(this.data), this.rows = this.data.map((t, e) => { const n = this._getNextRowCount(); let i = []; let o = { rowIndex: n }; if (Array.isArray(t)) for (this.options.checkboxColumn && i.push(this.getCheckboxHTML()), this.options.serialNoColumn && i.push(n + 1 + ""), i = i.concat(t); i.length < this.columns.length;)i.push(""); else { for (let e of this.columns) "_checkbox" === e.id ? i.push(this.getCheckboxHTML()) : "_rowIndex" === e.id ? i.push(n + 1 + "") : i.push(t[e.id]); o.indent = t.indent || 0 } return this.prepareRow(i, o) }) } prepareTreeRows() { this.rows.forEach((t, e) => { if (y(t.meta.indent)) { const n = this.getRow(e + 1); t.meta.isLeaf = !n || C(n.meta.indent) || n.meta.indent <= t.meta.indent } }) } prepareRowView() { this.rowViewOrder = this.rows.map(t => t.meta.rowIndex) } prepareRow(t, e) { const n = { rowIndex: e.rowIndex, indent: e.indent }; return t = t.map((t, e) => this.prepareCell(t, e)).map(t => Object.assign({}, n, t)), t.meta = e, t } validateColumns() { const t = this.options.columns; if (!Array.isArray(t)) throw new ot("`columns` must be an array"); t.forEach((t, e) => { if ("string" != typeof t && "object" != typeof t) throw new ot(`column "${e}" must be a string or an object`) }) } validateData(t) { if (Array.isArray(t) && (0 === t.length || Array.isArray(t[0]) || "object" == typeof t[0])) return !0; throw new ot("`data` must be an array of arrays or objects") } appendRows(t) { this.validateData(t), this.rows.push(...this.prepareRows(t)) } sortRows(t, e = "none") { t = +t, this.getColumns().map(n => { n.colIndex === t ? n.sortOrder = e : n.sortOrder = "none" }), this._sortRows(t, e) } _sortRows(t, e) { if (this.currentSort.colIndex === t && ("asc" === this.currentSort.sortOrder && "desc" === e || "desc" === this.currentSort.sortOrder && "asc" === e)) return this.reverseArray(this.rowViewOrder), void (this.currentSort.sortOrder = e); if (this.rowViewOrder.sort((n, i) => { const o = n; const s = i; const r = this.getCell(t, n).content; const a = this.getCell(t, i).content; if ("none" === e) return o - s; if ("asc" === e) { if (r < a) return -1; if (r > a) return 1; if (r === a) return 0 } else if ("desc" === e) { if (r < a) return 1; if (r > a) return -1; if (r === a) return 0 } return 0 }), this.hasColumnById("_rowIndex")) { const t = this.getColumnIndexById("_rowIndex"); this.rows.forEach((e, n) => { const i = this.rowViewOrder.indexOf(n); const o = e[t]; o.content = i + 1 + "" }) } } reverseArray(t) { let e = null, n = null; for (e = 0, n = t.length - 1; e < n; e += 1, n -= 1) { const i = t[e]; t[e] = t[n], t[n] = i } } switchColumn(t, e) { const n = this.columns[t]; this.columns[t] = this.columns[e], this.columns[e] = n, this.columns[t].colIndex = t, this.columns[e].colIndex = e, this.rows.forEach(n => { const i = Object.assign({}, n[t], { colIndex: e }); const o = Object.assign({}, n[e], { colIndex: t }); n[e] = i; n[t] = o }) } removeColumn(t) { t = +t; const e = e => e.colIndex !== t, n = (t, e) => Object.assign({}, t, { colIndex: e }); this.columns = this.columns.filter(e).map(n), this.rows.forEach(e => { e.splice(t, 1); e.forEach((t, e) => { t.colIndex = e }) }) } updateRow(t, e) { if (t.length < this.columns.length) { if (this.hasColumnById("_rowIndex")) { const n = e + 1 + ""; t = [n].concat(t) } if (this.hasColumnById("_checkbox")) { const e = '<input type="checkbox" />'; t = [e].concat(t) } } const n = this.prepareRow(t, e), i = this.rows.findIndex(t => t[0].rowIndex === e); return this.rows[i] = n, n } updateCell(t, e, n) { let i; "object" == typeof t && (t = (i = t).colIndex, e = i.rowIndex, n = i), i = this.getCell(t, e); for (let t in n) { const e = n[t]; void 0 !== e && (i[t] = e) } return i } updateColumn(t, e) { const n = this.getColumn(t); for (let t in e) { const i = e[t]; void 0 !== i && (n[t] = i) } return n } filterRows(t, e) { let n = [], i = []; return this.rows.map(t => t[e]).forEach(e => { const o = String(e.content || "").toLowerCase(); const s = (t || "").toLowerCase(); !s || o.includes(s) ? i.push(e.rowIndex) : n.push(e.rowIndex) }), this._filteredRows = i, { rowsToHide: n, rowsToShow: i } } getFilteredRowIndices() { return this._filteredRows || this.rows.map(t => t.meta.rowIndex) } getRowCount() { return this.rowCount } _getNextRowCount() { const t = this.rowCount; return this.rowCount++, t } getRows(t, e) { return this.rows.slice(t, e) } getRowsForView(t, e) { return this.rowViewOrder.map(t => this.rows[t]).slice(t, e) } getColumns(t) { let e = this.columns; return t && (e = e.slice(this.getStandardColumnCount())), e } getStandardColumnCount() { return this.options.checkboxColumn && this.options.serialNoColumn ? 2 : this.options.checkboxColumn || this.options.serialNoColumn ? 1 : 0 } getColumnCount(t) { let e = this.columns.length; return t && (e -= this.getStandardColumnCount()), e } getColumn(t) { return (t = +t) < 0 && (t = this.columns.length + t), this.columns.find(e => e.colIndex === t) } getColumnById(t) { return this.columns.find(e => e.id === t) } getRow(t) { return t = +t, this.rows[t] } getCell(t, e) { return e = +e, t = +t, this.getRow(e)[t] } getChildren(t) { t = +t; const e = this.getRow(t).meta.indent, n = []; for (let i = t + 1; i < this.rowCount; i++) { const t = this.getRow(i); if (!isNaN(t.meta.indent) && (t.meta.indent > e && n.push(i), t.meta.indent === e)) break } return n } getImmediateChildren(t) { t = +t; const e = this.getRow(t).meta.indent, n = [], i = e + 1; for (let o = t + 1; o < this.rowCount; o++) { const t = this.getRow(o); if (!(isNaN(t.meta.indent) || t.meta.indent > i) && (t.meta.indent === i && n.push(o), t.meta.indent === e)) break } return n } get() { return { columns: this.columns, rows: this.rows } } getData(t) { return this.data[t] } hasColumn(t) { return Boolean(this.columns.find(e => e.content === t)) } hasColumnById(t) { return Boolean(this.columns.find(e => e.id === t)) } getColumnIndex(t) { return this.columns.findIndex(e => e.content === t) } getColumnIndexById(t) { return this.columns.findIndex(e => e.id === t) } getCheckboxHTML() { return '<input type="checkbox" />' } } class ot extends TypeError { } class st { constructor(t) { this.instance = t, w(this, this.instance, ["options", "fireEvent", "header", "datamanager", "style", "wrapper", "rowmanager", "bodyScrollable"]), this.bindEvents(), rt = rt.bind(this, this.options.dropdownButton) } renderHeader() { this.header.innerHTML = "<thead></thead>", this.refreshHeader() } refreshHeader() { const t = this.datamanager.getColumns(), e = n.each(".data-table-cell[data-is-header]", this.header); !n(".data-table-cell", this.header) || t.length < e.length ? (n("thead", this.header).innerHTML = this.getHeaderHTML(t), this.$filterRow = n(".data-table-row[data-is-filter]", this.header), this.$filterRow && n.style(this.$filterRow, { display: "none" })) : e.map((e, i) => { const o = t[i]; n.data(e, { colIndex: o.colIndex }); const s = n(".sort-indicator", e); s && (s.innerHTML = this.options.sortIndicator[o.sortOrder]) }), this.$columnMap = [] } getHeaderHTML(t) { let e = this.rowmanager.getRowHTML(t, { isHeader: 1 }); return this.options.inlineFilters && (e += this.rowmanager.getRowHTML(t, { isFilter: 1 })), e } bindEvents() { this.bindDropdown(), this.bindResizeColumn(), this.bindMoveColumn(), this.bindFilter() } bindDropdown() { function t(t) { e && e.classList.remove("is-active"), e = null } let e; n.on(this.header, "click", ".data-table-dropdown-toggle", (i, o) => { const s = n.closest(".data-table-dropdown", o); s.classList.contains("is-active") ? t() : (t(), s.classList.add("is-active"), e = s) }), n.on(document.body, "click", e => { if (e.target.matches(".data-table-dropdown-toggle")) return; t() }); const i = this.options.headerDropdown; n.on(this.header, "click", ".data-table-dropdown-list > div", (t, e) => { const o = n.closest(".data-table-cell", e); const { index: index } = n.data(e); const { colIndex: colIndex } = n.data(o); let s = i[index].action; s && s.call(this.instance, this.getColumn(colIndex)) }) } bindResizeColumn() { let t, e, i, o = !1; n.on(this.header, "mousedown", ".data-table-cell .column-resizer", (s, r) => { document.body.classList.add("data-table-resize"); const a = r.parentNode.parentNode; t = a; const { colIndex: colIndex } = n.data(t); const l = this.getColumn(colIndex); if (l && !1 === l.resizable) return; o = !0; e = n.style(n(".content", t), "width"); i = s.pageX }), n.on(document.body, "mouseup", e => { document.body.classList.remove("data-table-resize"); if (!t) return; o = !1; const { colIndex: colIndex } = n.data(t); this.setColumnWidth(colIndex); this.style.setBodyStyle(); t = null }), n.on(document.body, "mousemove", s => { if (!o) return; const r = e + (s.pageX - i); const { colIndex: colIndex } = n.data(t); if (this.getColumnMinWidth(colIndex) > r) return; this.datamanager.updateColumn(colIndex, { width: r }); this.setColumnHeaderWidth(colIndex) }) } bindMoveColumn() { const e = () => { const e = n(".data-table-cell", this.header); if (!e) return; const i = n(".data-table-row", this.header); this.sortable = t.create(i, { onEnd: t => { const { oldIndex: oldIndex, newIndex: newIndex } = t; const e = t.item; const { colIndex: colIndex } = n.data(e); if (+colIndex === newIndex) return; this.switchColumn(oldIndex, newIndex) }, preventOnFilter: !1, filter: ".column-resizer, .data-table-dropdown", animation: 150 }) }; n.on(document.body, "mousemove", e) } bindSortColumn() { n.on(this.header, "click", ".data-table-cell .column-title", (t, e) => { const i = e.closest(".data-table-cell"); let { colIndex: colIndex, sortOrder: sortOrder = "none" } = n.data(i); const o = this.getColumn(colIndex); if (o && !1 === o.sortable) return; n(".sort-indicator", this.header).textContent = ""; n.each(".data-table-cell", this.header).map(t => { n.data(t, { sortOrder: "none" }) }); let s, r; "none" === sortOrder ? (s = "asc", r = "▲") : "asc" === sortOrder ? (s = "desc", r = "▼") : "desc" === sortOrder && (s = "none", r = ""); n.data(i, { sortOrder: s }); n(".sort-indicator", i).textContent = r; this.sortColumn(colIndex, s) }) } sortColumn(t, e) { this.instance.freeze(), this.sortRows(t, e).then(() => { this.refreshHeader(); return this.rowmanager.refreshRows() }).then(() => this.instance.unfreeze()).then(() => { this.fireEvent("onSortColumn", this.getColumn(t)) }) } removeColumn(t) { const e = this.getColumn(t); this.instance.freeze(), this.datamanager.removeColumn(t).then(() => { this.refreshHeader(); return this.rowmanager.refreshRows() }).then(() => this.instance.unfreeze()).then(() => { this.fireEvent("onRemoveColumn", e) }) } switchColumn(t, e) { this.instance.freeze(), this.datamanager.switchColumn(t, e).then(() => { this.refreshHeader(); return this.rowmanager.refreshRows() }).then(() => { this.setColumnWidth(t); this.setColumnWidth(e); this.instance.unfreeze() }).then(() => { this.fireEvent("onSwitchColumn", this.getColumn(t), this.getColumn(e)) }) } toggleFilter(t) { let e; (e = void 0 === t ? !this.isFilterShown : t) ? n.style(this.$filterRow, { display: "" }) : n.style(this.$filterRow, { display: "none" }), this.isFilterShown = e, this.style.setBodyStyle() } focusFilter(t) { this.isFilterShown && n(`[data-col-index="${t}"] .data-table-filter`, this.$filterRow).focus() } bindFilter() { if (this.options.inlineFilters) { const t = t => { const e = n.closest(".data-table-cell", t.target); const { colIndex: colIndex } = n.data(e); const i = t.target.value; this.datamanager.filterRows(i, colIndex).then(({ rowsToHide: rowsToHide, rowsToShow: rowsToShow }) => { this.rowmanager.hideRows(rowsToHide); this.rowmanager.showRows(rowsToShow) }) }; n.on(this.header, "keydown", ".data-table-filter", nt(t, 300)) } } sortRows(t, e) { return this.datamanager.sortRows(t, e) } getColumn(t) { return this.datamanager.getColumn(t) } getColumns() { return this.datamanager.getColumns() } setColumnWidth(t, e) { t = +t, this._columnWidthMap = this._columnWidthMap || []; let n = e || this.getColumn(t).width, i = this._columnWidthMap[t]; const o = `[data-col-index="${t}"] .content, [data-col-index="${t}"] .edit-cell`, s = { width: n + "px" }; void 0 !== (i = this.style.setStyle(o, s, i)) && (this._columnWidthMap[t] = i) } setColumnHeaderWidth(t) { t = +t, this.$columnMap = this.$columnMap || []; const e = `.data-table-header [data-col-index="${t}"] .content`, { width: width } = this.getColumn(t); let n = this.$columnMap[t]; n || (n = this.header.querySelector(e), this.$columnMap[t] = n), n.style.width = width + "px" } getColumnMinWidth(t) { return t = +t, this.getColumn(t).minWidth || 24 } getFirstColumnIndex() { return this.datamanager.getColumnIndexById("_rowIndex") + 1 } getHeaderCell$(t) { return n(`.data-table-cell[data-col-index="${t}"]`, this.header) } getLastColumnIndex() { return this.datamanager.getColumnCount() - 1 } getSerialColumnIndex() { return this.datamanager.getColumns().findIndex(t => t.content.includes("Sr. No")) } } var rt = function (t = "v") { return `<div class="data-table-dropdown-toggle">${t}</div>\n    <div class="data-table-dropdown-list">\n      ${this.options.headerDropdown.map((t, e) => `<div data-index="${e}">${t.label}</div>`).join("")}\n    </div>\n  ` }; class at { constructor(t) { this.instance = t, w(this, this.instance, ["wrapper", "options", "style", "bodyScrollable", "columnmanager", "rowmanager", "datamanager", "keyboard"]), this.bindEvents() } bindEvents() { this.bindFocusCell(), this.bindEditCell(), this.bindKeyboardSelection(), this.bindCopyCellContents(), this.bindMouseEvents(), this.bindTreeEvents() } bindFocusCell() { this.bindKeyboardNav() } bindEditCell() { this.$editingCell = null, n.on(this.bodyScrollable, "dblclick", ".data-table-cell", (t, e) => { this.activateEditing(e) }), this.keyboard.on("enter", t => { this.$focusedCell && !this.$editingCell ? this.activateEditing(this.$focusedCell) : this.$editingCell && (this.submitEditing(), this.deactivateEditing()) }) } bindKeyboardNav() { const t = t => { if (!this.$focusedCell || this.$editingCell) return !1; let e = this.$focusedCell; "left" === t || "shift+tab" === t ? e = this.getLeftCell$(e) : "right" === t || "tab" === t ? e = this.getRightCell$(e) : "up" === t ? e = this.getAboveCell$(e) : "down" === t && (e = this.getBelowCell$(e)); this.focusCell(e); return !0 }, e = t => { if (!this.$focusedCell || this.$editingCell) return !1; let e = this.$focusedCell; const { rowIndex: rowIndex, colIndex: colIndex } = n.data(e); "left" === t ? e = this.getLeftMostCell$(rowIndex) : "right" === t ? e = this.getRightMostCell$(rowIndex) : "up" === t ? e = this.getTopMostCell$(colIndex) : "down" === t && (e = this.getBottomMostCell$(colIndex)); this.focusCell(e); return !0 };["left", "right", "up", "down", "tab", "shift+tab"].map(e => this.keyboard.on(e, () => t(e))), ["left", "right", "up", "down"].map(t => this.keyboard.on("ctrl+" + t, () => e(t))), this.keyboard.on("esc", () => { this.deactivateEditing() }), this.options.inlineFilters && this.keyboard.on("ctrl+f", t => { const e = n.closest(".data-table-cell", t.target); let { colIndex: colIndex } = n.data(e); this.activateFilter(colIndex); return !0 }) } bindKeyboardSelection() { const t = t => { let e = this.getSelectionCursor(); "left" === t ? e = this.getLeftCell$(e) : "right" === t ? e = this.getRightCell$(e) : "up" === t ? e = this.getAboveCell$(e) : "down" === t && (e = this.getBelowCell$(e)); return e };["left", "right", "up", "down"].map(e => this.keyboard.on("shift+" + e, () => this.selectArea(t(e)))) } bindCopyCellContents() { this.keyboard.on("ctrl+c", () => { this.copyCellContents(this.$focusedCell, this.$selectionCursor) }) } bindMouseEvents() { let t = null; n.on(this.bodyScrollable, "mousedown", ".data-table-cell", e => { t = !0; this.focusCell(n(e.delegatedTarget)) }), n.on(this.bodyScrollable, "mouseup", () => { t = !1 }); const e = e => { if (!t) return; this.selectArea(n(e.delegatedTarget)) }; n.on(this.bodyScrollable, "mousemove", ".data-table-cell", et(e, 50)) } bindTreeEvents() { n.on(this.bodyScrollable, "click", ".toggle", (t, e) => { const i = n.closest(".data-table-cell", e); const { rowIndex: rowIndex } = n.data(i); i.classList.contains("tree-close") ? this.rowmanager.openSingleNode(rowIndex) : this.rowmanager.closeSingleNode(rowIndex) }) } focusCell(t, { skipClearSelection: skipClearSelection = 0 } = {}) { if (t && t !== this.$editingCell) { const { colIndex: colIndex, isHeader: isHeader } = n.data(t); isHeader || !1 !== this.columnmanager.getColumn(colIndex).focusable && (this.scrollToCell(t), this.deactivateEditing(), skipClearSelection || this.clearSelection(), this.$focusedCell && this.$focusedCell.classList.remove("selected"), this.$focusedCell = t, t.classList.add("selected"), t.focus(), this.highlightRowColumnHeader(t)) } } highlightRowColumnHeader(t) { const { colIndex: colIndex, rowIndex: rowIndex } = n.data(t), e = `.data-table-header .data-table-cell[data-col-index="${colIndex}"]`, i = `.data-table-cell[data-row-index="${rowIndex}"][data-col-index="${this.datamanager.getColumnIndexById("_rowIndex")}"]`; this.lastHeaders && n.removeStyle(this.lastHeaders, "backgroundColor"); const o = n(e, this.wrapper), s = n(i, this.wrapper); n.style([o, s], { backgroundColor: "#f5f7fa" }), this.lastHeaders = [o, s] } selectAreaOnClusterChanged() { if (this.$focusedCell && this.$selectionCursor) { const { colIndex: colIndex, rowIndex: rowIndex } = n.data(this.$selectionCursor), t = this.getCell$(colIndex, rowIndex); if (t && t !== this.$selectionCursor) { const e = n.data(this.$focusedCell); this.$focusedCell = this.getCell$(e.colIndex, e.rowIndex), this.selectArea(t) } } } focusCellOnClusterChanged() { if (this.$focusedCell) { const { colIndex: colIndex, rowIndex: rowIndex } = n.data(this.$focusedCell), t = this.getCell$(colIndex, rowIndex); t && this.focusCell(t, { skipClearSelection: 1 }) } } selectArea(t) { this.$focusedCell && this._selectArea(this.$focusedCell, t) && (this.$selectionCursor = t) } _selectArea(t, e) { if (t === e) return !1; const n = this.getCellsInRange(t, e); return !!n && (this.clearSelection(), n.map(t => this.getCell$(...t)).map(t => t.classList.add("highlight")), !0) } getCellsInRange(t, e) { let i, o, s, r; if ("number" == typeof t) [i, o, s, r] = arguments; else if ("object" == typeof t) { if (!t || !e) return !1; const a = n.data(t), l = n.data(e); i = a.colIndex, o = a.rowIndex, s = l.colIndex, r = l.rowIndex } if (o > r && ([o, r] = [r, o]), i > s && ([i, s] = [s, i]), this.isStandardCell(i) || this.isStandardCell(s)) return !1; let a = [], l = i, c = o, h = []; for (; c <= r;)h.push(c), c++; return h.map(t => { for (; l <= s;)a.push([l, t]), l++; l = i }), a } clearSelection() { n.each(".data-table-cell.highlight", this.bodyScrollable).map(t => t.classList.remove("highlight")), this.$selectionCursor = null } getSelectionCursor() { return this.$selectionCursor || this.$focusedCell } activateEditing(t) { this.focusCell(t); const { rowIndex: rowIndex, colIndex: colIndex } = n.data(t), e = this.columnmanager.getColumn(colIndex); if (!e || !1 !== e.editable && !1 !== e.focusable) { const i = this.getCell(colIndex, rowIndex); if (!i || !1 !== i.editable) { if (this.$editingCell) { const { _rowIndex: _rowIndex, _colIndex: _colIndex } = n.data(this.$editingCell); if (rowIndex === _rowIndex && colIndex === _colIndex) return } this.$editingCell = t, t.classList.add("editing"); const o = n(".edit-cell", t); o.innerHTML = ""; const s = this.getEditor(colIndex, rowIndex, i.content, o); s && (this.currentCellEditor = s, s.initValue(i.content, rowIndex, e)) } } } deactivateEditing() { this.$focusedCell && this.$focusedCell.focus(), this.$editingCell && (this.$editingCell.classList.remove("editing"), this.$editingCell = null) } getEditor(t, e, n, i) { const o = this.datamanager.getColumn(t), s = this.datamanager.getRow(e), r = this.datamanager.getData(e); let a = this.options.getEditor ? this.options.getEditor(t, e, n, i, o, s, r) : this.getDefaultEditor(i); return !1 !== a && (void 0 === a && (a = this.getDefaultEditor(i)), a) } getDefaultEditor(t) { const e = n.create("input", { class: "input-style", type: "text", inside: t }); return { initValue(t) { e.focus(), e.value = t }, getValue() { return e.value }, setValue(t) { e.value = t } } } submitEditing() { if (this.$editingCell) { const t = this.$editingCell, { rowIndex: rowIndex, colIndex: colIndex } = n.data(t), e = this.datamanager.getColumn(colIndex); if (t) { const n = this.currentCellEditor; if (n) { const i = n.getValue(), o = n.setValue(i, rowIndex, e), s = this.getCell(colIndex, rowIndex).content; this.updateCell(colIndex, rowIndex, i), t.focus(), o && o.then && o.catch(t => { console.log(t); this.updateCell(colIndex, rowIndex, s) }) } } this.currentCellEditor = null } } copyCellContents(t, e) { if (!e && t) { const { colIndex: colIndex, rowIndex: rowIndex } = n.data(t), e = this.getCell(colIndex, rowIndex); return void m(e.content) } const i = this.getCellsInRange(t, e); i && m(i.map(t => this.getCell(...t)).reduce((t, e) => { const n = e.rowIndex; t[n] = t[n] || []; t[n].push(e.content); return t }, []).map(t => t.join("\t")).join("\n")) } activateFilter(t) { this.columnmanager.toggleFilter(), this.columnmanager.focusFilter(t), this.columnmanager.isFilterShown || this.$focusedCell.focus() } updateCell(t, e, n) { const i = this.datamanager.updateCell(t, e, { content: n }); this.refreshCell(i) } refreshCell(t) { n(this.selector(t.colIndex, t.rowIndex), this.bodyScrollable).innerHTML = this.getCellContent(t) } toggleTreeButton(t, e) { const n = this.columnmanager.getFirstColumnIndex(), i = this.getCell$(n, t); i && i.classList[e ? "remove" : "add"]("tree-close") } isStandardCell(t) { return t < this.columnmanager.getFirstColumnIndex() } getCell$(t, e) { return n(this.selector(t, e), this.bodyScrollable) } getAboveCell$(t) { const { colIndex: colIndex } = n.data(t); let e = t.parentElement.previousElementSibling; for (; e && e.classList.contains("hide");)e = e.previousElementSibling; return e ? n(`[data-col-index="${colIndex}"]`, e) : t } getBelowCell$(t) { const { colIndex: colIndex } = n.data(t); let e = t.parentElement.nextElementSibling; for (; e && e.classList.contains("hide");)e = e.nextElementSibling; return e ? n(`[data-col-index="${colIndex}"]`, e) : t } getLeftCell$(t) { return t.previousElementSibling } getRightCell$(t) { return t.nextElementSibling } getLeftMostCell$(t) { return this.getCell$(this.columnmanager.getFirstColumnIndex(), t) } getRightMostCell$(t) { return this.getCell$(this.columnmanager.getLastColumnIndex(), t) } getTopMostCell$(t) { return this.getCell$(t, this.rowmanager.getFirstRowIndex()) } getBottomMostCell$(t) { return this.getCell$(t, this.rowmanager.getLastRowIndex()) } getCell(t, e) { return this.instance.datamanager.getCell(t, e) } getCellAttr(t) { return this.instance.getCellAttr(t) } getRowHeight() { return n.style(n(".data-table-row", this.bodyScrollable), "height") } scrollToCell(t) { if (n.inViewport(t, this.bodyScrollable)) return !1; const { rowIndex: rowIndex } = n.data(t); return this.rowmanager.scrollToRow(rowIndex), !1 } getRowCountPerPage() { return Math.ceil(this.instance.getViewportHeight() / this.getRowHeight()) } getCellHTML(t) { const { rowIndex: rowIndex, colIndex: colIndex, isHeader: isHeader, isFilter: isFilter } = t; return `\n            <td class="data-table-cell noselect" ${f({ rowIndex: rowIndex, colIndex: colIndex, isHeader: isHeader, isFilter: isFilter })} tabindex="0">\n                ${this.getCellContent(t)}\n            </td>\n        ` } getCellContent(t) { const { isHeader: isHeader, isFilter: isFilter } = t, e = !isHeader && !1 !== t.editable ? this.getEditCellHTML() : "", n = isHeader && !1 !== t.sortable ? '<span class="sort-indicator"></span>' : "", i = isHeader && !1 !== t.resizable ? '<span class="column-resizer"></span>' : "", o = isHeader && !1 !== t.dropdown ? `<div class="data-table-dropdown">${rt()}</div>` : "", s = t.format || t.column && t.column.format || null; let r; if (isHeader || isFilter || !s) r = t.content; else { const e = this.datamanager.getRow(t.rowIndex), n = this.datamanager.getData(t.rowIndex); r = s(t.content, e, t.column, n) } if (this.options.treeView && !isHeader && !isFilter && void 0 !== t.indent) { const e = this.datamanager.getRow(t.rowIndex + 1), n = e && e.meta.indent > t.indent, i = this.datamanager.getColumnIndexById("_rowIndex") + 1; if (i === t.colIndex) { const e = 1.5 * ((t.indent || 0) + 1), i = n ? `<span class="toggle" style="left: ${e - 1.5}rem"></span>` : ""; r = `<span class="tree-node" style="padding-left: ${e}rem">\n                    ${i}${r}</span>` } } return `\n            <div class="content ellipsis">\n                ${r}\n                ${n}\n                ${i}\n                ${o}\n            </div>\n            ${e}\n        ` } getEditCellHTML() { return `\n      <div class="edit-cell"></div>\n    ` } selector(t, e) { return `.data-table-cell[data-col-index="${t}"][data-row-index="${e}"]` } } class lt { constructor(t) { this.instance = t, w(this, this.instance, ["options", "fireEvent", "wrapper", "bodyScrollable", "bodyRenderer"]), this.bindEvents(), this.refreshRows = p(this.refreshRows, this) } get datamanager() { return this.instance.datamanager } get cellmanager() { return this.instance.cellmanager } bindEvents() { this.bindCheckbox() } bindCheckbox() { this.options.checkboxColumn && (this.checkMap = [], n.on(this.wrapper, "click", '.data-table-cell[data-col-index="0"] [type="checkbox"]', (t, e) => { const i = e.closest(".data-table-cell"); const { rowIndex: rowIndex, isHeader: isHeader } = n.data(i); const o = e.checked; isHeader ? this.checkAll(o) : this.checkRow(rowIndex, o) })) } refreshRows() { this.instance.renderBody(), this.instance.setDimensions() } refreshRow(t, e) { this.datamanager.updateRow(t, e).forEach(t => { this.cellmanager.refreshCell(t) }) } getCheckedRows() { if (!this.checkMap) return []; let t = []; for (let e in this.checkMap) { const n = this.checkMap[e]; 1 === n && t.push(e) } return t } highlightCheckedRows() { this.getCheckedRows().map(t => this.checkRow(t, !0)) } checkRow(t, e) { const i = e ? 1 : 0, o = t => `.data-table-cell[data-row-index="${t}"][data-col-index="0"] [type="checkbox"]`; this.checkMap[t] = i, n.each(o(t), this.bodyScrollable).map(t => { t.checked = e }), this.highlightRow(t, e), this.showCheckStatus(), this.fireEvent("onCheckRow", this.datamanager.getRow(t)) } checkAll(t) { const e = t ? 1 : 0; this.checkMap = t ? Array.from(Array(this.getTotalRows())).map(t => e) : [], n.each('.data-table-cell[data-col-index="0"] [type="checkbox"]', this.bodyScrollable).map(e => { e.checked = t }), this.highlightAll(t), this.showCheckStatus() } showCheckStatus() { if (this.options.checkedRowStatus) { const t = this.getCheckedRows().length; t > 0 ? this.bodyRenderer.showToastMessage(`${t} row${t > 1 ? "s" : ""} selected`) : this.bodyRenderer.clearToastMessage() } } highlightRow(t, e = !0) { const n = this.getRow$(t); if (n) { if (!e && this.bodyScrollable.classList.contains("row-highlight-all")) return void n.classList.add("row-unhighlight"); e && n.classList.contains("row-unhighlight") && n.classList.remove("row-unhighlight"), this._highlightedRows = this._highlightedRows || {}, e ? (n.classList.add("row-highlight"), this._highlightedRows[t] = n) : (n.classList.remove("row-highlight"), delete this._highlightedRows[t]) } } highlightAll(t = !0) { if (t) this.bodyScrollable.classList.add("row-highlight-all"); else { this.bodyScrollable.classList.remove("row-highlight-all"); for (const t in this._highlightedRows) { const e = this._highlightedRows[t]; e.classList.remove("row-highlight") } this._highlightedRows = {} } } hideRows(t) { (t = x(t)).map(t => { const e = this.getRow$(t); e.classList.add("hide") }) } showRows(t) { (t = x(t)).map(t => { const e = this.getRow$(t); e.classList.remove("hide") }) } openSingleNode(t) { const e = this.datamanager.getImmediateChildren(t); this.showRows(e), this.cellmanager.toggleTreeButton(t, !0) } closeSingleNode(t) { this.datamanager.getImmediateChildren(t).forEach(t => { const e = this.datamanager.getRow(t); e.meta.isLeaf ? (this.hideRows(t), this.cellmanager.toggleTreeButton(t, !1)) : (this.closeSingleNode(t), this.hideRows(t)) }), this.cellmanager.toggleTreeButton(t, !1) } getRow$(t) { return n(this.selector(t), this.bodyScrollable) } getTotalRows() { return this.datamanager.getRowCount() } getFirstRowIndex() { return 0 } getLastRowIndex() { return this.datamanager.getRowCount() - 1 } scrollToRow(t) { t = +t, this._lastScrollTo = this._lastScrollTo || 0; const e = this.getRow$(t); if (!n.inViewport(e, this.bodyScrollable)) { const { height: height } = e.getBoundingClientRect(), { top: top, bottom: bottom } = this.bodyScrollable.getBoundingClientRect(), i = Math.floor((bottom - top) / height); let o = 0; o = t > this._lastScrollTo ? height * (t + 1 - i) : height * (t + 1 - 1), this._lastScrollTo = t, n.scrollTop(this.bodyScrollable, o) } } getRowHTML(t, e) { const n = f(e); return e.isFilter && (t = t.map(t => Object.assign({}, t, { content: this.getFilterInput({ colIndex: t.colIndex }), isFilter: 1, isHeader: void 0, editable: !1 }))), `\n            <tr class="data-table-row" ${n}>\n                ${t.map(t => this.cellmanager.getCellHTML(t)).join("")}\n            </tr>\n        ` } getFilterInput(t) { return `<input class="data-table-filter input-style" type="text" ${f(t)} />` } selector(t) { return `.data-table-row[data-row-index="${t}"]` } } class ct { constructor(t) { this.instance = t, this.options = t.options, this.datamanager = t.datamanager, this.rowmanager = t.rowmanager, this.cellmanager = t.cellmanager, this.bodyScrollable = t.bodyScrollable, this.log = t.log, this.appendRemainingData = p(this.appendRemainingData, this) } render() { this.options.clusterize ? this.renderBodyWithClusterize() : this.renderBodyHTML() } renderBodyHTML() { const t = this.datamanager.getRowsForView(); this.bodyScrollable.innerHTML = `\n            <table class="data-table-body">\n                ${this.getBodyHTML(t)}\n            </table>\n        `, this.instance.setDimensions(), this.restoreState() } renderBodyWithClusterize() { const t = this.datamanager.getRowsForView(0, 20); let i = this.getDataForClusterize(t); 0 === i.length && (i = [`<tr class="no-data"><td>${this.options.noDataMessage}</td></tr>`]), this.clusterize ? this.clusterize.update(i) : (this.bodyScrollable.innerHTML = `\n                <table class="data-table-body">\n                    ${this.getBodyHTML([])}\n                </table>\n            `, this.clusterize = new e({ rows: i, scrollElem: this.bodyScrollable, contentElem: n("tbody", this.bodyScrollable), callbacks: { clusterChanged: () => { this.restoreState() } }, show_no_data_row: !1 }), this.instance.setDimensions()), this.appendRemainingData() } restoreState() { this.rowmanager.highlightCheckedRows(), this.cellmanager.selectAreaOnClusterChanged(), this.cellmanager.focusCellOnClusterChanged() } appendRemainingData() { const t = this.datamanager.getRowsForView(20), e = this.getDataForClusterize(t); this.clusterize.append(e) } showToastMessage(t) { this.instance.toastMessage.innerHTML = `<span>${t}</span>` } clearToastMessage() { this.instance.toastMessage.innerHTML = "" } getDataForClusterize(t) { return t.map(t => this.rowmanager.getRowHTML(t, t.meta)) } getBodyHTML(t) { return `\n            <tbody>\n                ${t.map(t => this.rowmanager.getRowHTML(t, t.meta)).join("")}\n            </tbody>\n        ` } } class ht { constructor(t) { this.instance = t, w(this, this.instance, ["options", "datamanager", "columnmanager", "header", "bodyScrollable", "datatableWrapper", "getColumn"]), this.scopeClass = "datatable-instance-" + t.constructor.instances, t.datatableWrapper.classList.add(this.scopeClass); const e = document.createElement("style"); t.wrapper.insertBefore(e, t.datatableWrapper), this.styleEl = e, this.bindResizeWindow() } get stylesheet() { return this.styleEl.sheet } bindResizeWindow() { "fluid" === this.options.layout && n.on(window, "resize", et(() => { this.distributeRemainingWidth(); this.refreshColumnWidth(); this.compensateScrollbarWidth(); this.setBodyStyle() }, 300)) } destroy() { this.styleEl.remove() } setStyle(t, e, n = -1) { const i = Object.keys(e).map(t => { t.includes("-") || (t = d(t)); return `${t}:${e[t]};` }).join(""); let o = `${t.split(",").map(t => `.${this.scopeClass} ${t}`).join(",")} { ${i} }`; if (this.stylesheet) { let t = this.stylesheet.cssRules.length; return -1 !== n && (this.stylesheet.deleteRule(n), t = n), this.stylesheet.insertRule(o, t), t } } setDimensions() { this.setHeaderStyle(), this.setupMinWidth(), this.setupNaturalColumnWidth(), this.setupColumnWidth(), this.distributeRemainingWidth(), this.setColumnStyle(), this.compensateScrollbarWidth(), this.setDefaultCellHeight(), this.setBodyStyle() } setHeaderStyle() { "fluid" === this.options.layout && n.style(this.header, { width: 0 }), n.style(this.header, { margin: 0 }); const t = this.datamanager.getColumns().filter(t => !1 === t.resizable).map(t => t.colIndex).map(t => `.data-table-header [data-col-index="${t}"]`).join(); this.setStyle(t, { cursor: "pointer" }) } setupMinWidth() { n.each(".data-table-cell[data-is-header]", this.header).map(t => { const e = n.style(n(".content", t), "width"); const { colIndex: colIndex } = n.data(t); const i = this.getColumn(colIndex); i.minWidth || (i.minWidth = e) }) } setupNaturalColumnWidth() { n(".data-table-row") && n.each('.data-table-row[data-row-index="0"] .data-table-cell', this.bodyScrollable).map(t => { const { colIndex: colIndex } = n.data(t); const e = this.datamanager.getColumn(colIndex); let i = n.style(n(".content", t), "width"); "_rowIndex" === e.id && (i = this.getRowIndexColumnWidth(i), e.width = i); e.naturalWidth = i }) } setupColumnWidth() { if ("ratio" === this.options.layout) { let t = n.style(this.datatableWrapper, "width"); if (this.options.serialNoColumn) { const e = this.datamanager.getColumnById("_rowIndex"); t = t - e.width - 1 } if (this.options.checkboxColumn) { const e = this.datamanager.getColumnById("_checkbox"); t = t - e.width - 1 } const e = this.datamanager.getColumns().map(t => { if ("_rowIndex" === t.id || "_checkbox" === t.id) return 0; t.width || (t.width = 1); t.ratioWidth = parseInt(t.width, 10); return t.ratioWidth }).reduce((t, e) => t + e), i = t / e; this.datamanager.getColumns().map(t => { if ("_rowIndex" === t.id || "_checkbox" === t.id) return; t.width = Math.floor(i * t.ratioWidth) - 1 }) } else this.datamanager.getColumns().map(t => { t.width || (t.width = t.naturalWidth); t.width < t.minWidth && (t.width = t.minWidth) }) } compensateScrollbarWidth() { const t = n.scrollbarWidth(), e = this.datamanager.getColumn(-1), i = e.width - t; this.columnmanager.setColumnWidth(e.colIndex, i) } distributeRemainingWidth() { if ("fluid" === this.options.layout) { const t = n.style(this.instance.datatableWrapper, "width"), e = n.style(this.header, "width"), i = this.datamanager.getColumns().filter(t => t.resizable), o = (t - e) / i.length; i.map(t => { const e = n.style(this.getColumnHeaderElement(t.colIndex), "width"); let i = Math.floor(e + o) - 2; this.datamanager.updateColumn(t.colIndex, { width: i }) }) } } setDefaultCellHeight() { if (!this.options.dynamicRowHeight && !this.__cellHeightSet) { const t = n(".data-table-cell[data-is-header]", this.instance.header); if (t) { const e = this.options.cellHeight || n.style(t, "height"); e && (this.setCellHeight(e), this.__cellHeightSet = !0) } } } setCellHeight(t) { this.setStyle(".data-table-cell .content", { height: t + "px" }), this.setStyle(".data-table-cell .edit-cell", { height: t + "px" }) } setColumnStyle() { this.datamanager.getColumns().map(t => { ["left", "center", "right"].includes(t.align) && this.setStyle(`[data-col-index="${t.colIndex}"]`, { "text-align": t.align }); this.columnmanager.setColumnHeaderWidth(t.colIndex); this.columnmanager.setColumnWidth(t.colIndex) }), this.setBodyStyle() } refreshColumnWidth() { this.datamanager.getColumns().map(t => { this.columnmanager.setColumnHeaderWidth(t.colIndex); this.columnmanager.setColumnWidth(t.colIndex) }) } setBodyStyle() { const t = n.style(this.header, "width"); n.style(this.bodyScrollable, { width: t + "px" }); const e = n(".data-table-body", this.bodyScrollable); e && n.style(e, { height: "0px" }), n.style(this.bodyScrollable, { marginTop: n.style(this.header, "height") + "px" }), n.style(n("table", this.bodyScrollable), { margin: 0, width: "100%" }) } getColumnHeaderElement(t) { return t = +t, t < 0 ? null : n(`.data-table-cell[data-col-index="${t}"]`, this.header) } getRowIndexColumnWidth(t) { this._rowIndexColumnWidthMap = this._rowIndexColumnWidthMap || {}; const e = (this.datamanager.getRowCount() + "").length; return this._rowIndexColumnWidthMap[e] || (this._rowIndexColumnWidthMap[e] = t + 8 * (e - 1)), this._rowIndexColumnWidthMap[e] } } const ut = { 13: "enter", 91: "meta", 16: "shift", 17: "ctrl", 18: "alt", 37: "left", 38: "up", 39: "right", 40: "down", 9: "tab", 27: "esc", 67: "c", 70: "f" }; class dt { constructor(t) { this.listeners = {}, n.on(t, "keydown", this.handler.bind(this)) } handler(t) { let e = ut[t.keyCode]; t.shiftKey && "shift" !== e && (e = "shift+" + e), (t.ctrlKey && "ctrl" !== e || t.metaKey && "meta" !== e) && (e = "ctrl+" + e); const n = this.listeners[e]; if (n && n.length > 0) for (let e of n) { const n = e(t); void 0 !== n && !0 !== n || t.preventDefault() } } on(t, e) { t.split(",").map(t => t.trim()).map(t => { this.listeners[t] = this.listeners[t] || []; this.listeners[t].push(e) }) } } var ft = { columns: [], data: [], dropdownButton: "▼", headerDropdown: [{ label: "Sort Ascending", action: function (t) { this.sortColumn(t.colIndex, "asc") } }, { label: "Sort Descending", action: function (t) { this.sortColumn(t.colIndex, "desc") } }, { label: "Reset sorting", action: function (t) { this.sortColumn(t.colIndex, "none") } }, { label: "Remove column", action: function (t) { this.removeColumn(t.colIndex) } }], events: { onRemoveColumn(t) { }, onSwitchColumn(t, e) { }, onSortColumn(t) { }, onCheckRow(t) { } }, sortIndicator: { asc: "↑", desc: "↓", none: "" }, freezeMessage: "", getEditor: null, serialNoColumn: !0, checkboxColumn: !1, clusterize: !0, logs: !1, layout: "fixed", noDataMessage: "No Data", cellHeight: null, inlineFilters: !1, treeView: !1, checkedRowStatus: !0, dynamicRowHeight: !1 }; class mt { constructor(t, e) { if (mt.instances++, "string" == typeof t && (t = document.querySelector(t)), this.wrapper = t, !(this.wrapper instanceof HTMLElement)) throw new Error("Invalid argument given for `wrapper`"); this.buildOptions(e), this.prepare(), this.style = new ht(this), this.keyboard = new dt(this.wrapper), this.datamanager = new it(this.options), this.rowmanager = new lt(this), this.columnmanager = new st(this), this.cellmanager = new at(this), this.bodyRenderer = new ct(this), this.options.data && this.refresh() } buildOptions(t) { this.options = this.options || {}, this.options = Object.assign({}, ft, this.options || {}, t), this.options.headerDropdown.push(...t.headerDropdown || []), this.events = Object.assign({}, ft.events, this.options.events || {}, t.events || {}), this.fireEvent = this.fireEvent.bind(this) } prepare() { this.prepareDom(), this.unfreeze() } prepareDom() { this.wrapper.innerHTML = `\n            <div class="data-table">\n                <table class="data-table-header">\n                </table>\n                <div class="body-scrollable">\n                </div>\n                <div class="freeze-container">\n                <span>${this.options.freezeMessage}</span>\n                </div>\n                <div class="data-table-footer">\n                </div>\n                <div class="toast-message"></div>\n            </div>\n        `, this.datatableWrapper = n(".data-table", this.wrapper), this.header = n(".data-table-header", this.wrapper), this.bodyScrollable = n(".body-scrollable", this.wrapper), this.freezeContainer = n(".freeze-container", this.wrapper), this.toastMessage = n(".toast-message", this.wrapper) } refresh(t, e) { this.datamanager.init(t, e), this.render(), this.setDimensions() } destroy() { this.wrapper.innerHTML = "", this.style.destroy() } appendRows(t) { this.datamanager.appendRows(t), this.rowmanager.refreshRows() } refreshRow(t, e) { this.rowmanager.refreshRow(t, e) } render() { this.renderHeader(), this.renderBody() } renderHeader() { this.columnmanager.renderHeader() } renderBody() { this.bodyRenderer.render() } setDimensions() { this.style.setDimensions() } showToastMessage(t) { this.bodyRenderer.showToastMessage(t) } clearToastMessage() { this.bodyRenderer.clearToastMessage() } getColumn(t) { return this.datamanager.getColumn(t) } getColumns() { return this.datamanager.getColumns() } getRows() { return this.datamanager.getRows() } getCell(t, e) { return this.datamanager.getCell(t, e) } getColumnHeaderElement(t) { return this.columnmanager.getColumnHeaderElement(t) } getViewportHeight() { return this.viewportHeight || (this.viewportHeight = n.style(this.bodyScrollable, "height")), this.viewportHeight } sortColumn(t, e) { this.columnmanager.sortColumn(t, e) } removeColumn(t) { this.columnmanager.removeColumn(t) } scrollToLastColumn() { this.datatableWrapper.scrollLeft = 9999 } freeze() { n.style(this.freezeContainer, { display: "" }) } unfreeze() { n.style(this.freezeContainer, { display: "none" }) } updateOptions(t) { this.buildOptions(t) } fireEvent(t, ...e) { this.events[t].apply(this, e) } log() { this.options.logs && console.log.apply(console, arguments) } } mt.instances = 0; var gt = { name: "frappe-datatable", version: "0.0.4", description: "A modern datatable library for the web", main: "dist/frappe-datatable.cjs.js", scripts: { start: "yarn run dev", build: "rollup -c", production: "rollup -c --production", "build:docs": "rollup -c --docs", dev: "rollup -c -w", test: "mocha --compilers js:babel-core/register --colors ./test/*.spec.js", "test:watch": "mocha --compilers js:babel-core/register --colors -w ./test/*.spec.js" }, devDependencies: { chai: "3.5.0", cssnano: "^3.10.0", deepmerge: "^2.0.1", eslint: "3.19.0", "eslint-loader": "1.7.1", mocha: "3.3.0", "postcss-cssnext": "^3.1.0", "postcss-nested": "^3.0.0", precss: "^3.1.0", "rollup-plugin-commonjs": "^8.3.0", "rollup-plugin-json": "^2.3.0", "rollup-plugin-node-resolve": "^3.0.3", "rollup-plugin-postcss": "^1.2.8", "rollup-plugin-uglify": "^3.0.0", "rollup-plugin-uglify-es": "^0.0.1" }, repository: { type: "git", url: "https://github.com/frappe/datatable.git" }, keywords: ["datatable", "data", "grid", "table"], author: "Faris Ansari", license: "MIT", bugs: { url: "https://github.com/frappe/datatable/issues" }, homepage: "https://frappe.github.io/datatable", dependencies: { "clusterize.js": "^0.18.0", lodash: "^4.17.5", sortablejs: "^1.7.0" } }; return mt.__version__ = gt.version, mt }(Sortable, Clusterize);
